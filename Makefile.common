
ifdef $(GITHUB_REPOSITORY)
OWNER=$(shell echo $(GITHUB_REPOSITORY) | cut -d/ -f1)
REPOSITORY=$(shell echo $(GITHUB_REPOSITORY) | cut -d/ -f2-)
endif
OWNER ?= starcard-org
REPOSITORY ?= $(shell basename $(PWD))

# default artifact attributes
export DOCKER_IMAGE ?= $(OWNER)/$(REPOSITORY)/$(shell echo $(REPOSITORY) | sed -E 's|^pti-||')
export DOCKER_TAG ?= $(shell V="$$(git describe --tags --match='[0-9][0-9.]*' --dirty 2>/dev/null)"; if [ "$$V" = "" ]; then git fetch --no-tags --prune origin +refs/heads/master:refs/remotes/origin/master && echo "0.0.0-$$(git rev-list --count origin/master)-$$(git rev-parse --short HEAD)"; else echo "$$V"; fi)
export DOCKER_REGISTRY ?= docker.pkg.github.com
ECR_REGISTRY ?= 210944367560.dkr.ecr.us-west-2.amazonaws.com

# can be used to define an HTTP proxy for APT, for example
# DOCKER_BUILD_ARGS="--build-arg http_proxy=http://my.proxy:1080
DOCKER_BUILD_ARGS ?= --pull

# test entrypoint to look for and execute
TEST_ENTRYPOINT ?= test/run

# function to check if a make/environment variable is set
define check_defined
	test -n "$($(1))" && { \
		exit 0; \
	} || { \
		echo "\n\033[1;31mVariable $1 must be defined.\033[0m\n"; \
		exit 1; \
	}
endef

# show a colorized comment
define logme
	echo "\n\033[1;32m--- [$(@)] $(1) ---\033[0m\n"
endef

all: usage

usage:
	@echo "make [all|usage|clean|build|release|test]"

clean:
	@$(call check_defined,DOCKER_TAG)

	docker rmi -f $(DOCKER_REGISTRY)/$(DOCKER_IMAGE):$(DOCKER_TAG) 2>/dev/null || true

docker-login:
	@$(call check_defined,DOCKER_USERNAME)
	@$(call check_defined,DOCKER_PASSWORD)

	docker login -u $(DOCKER_USERNAME) -p $(DOCKER_PASSWORD) $(DOCKER_REGISTRY) >/dev/null 2>&1
ecr-login:
	@$(call check_defined,AWS_ACCESS_KEY_ID)
	@$(call check_defined,AWS_SECRET_ACCESS_KEY)

	aws ecr get-login-password | docker login --username AWS --password-stdin ${ECR_REGISTRY}

build:
	@$(call check_defined,DOCKER_TAG)

	@$(call logme,"Build base image")
	docker build \
		--file Dockerfile \
		--tag $(DOCKER_REGISTRY)/$(DOCKER_IMAGE):$(DOCKER_TAG) \
		--label build.commit.hash="$(shell git log -1 --format=%H)" \
		--label build.commit.shorthash="$(shell git log -1 --format=%h)" \
		--label build.docker.image.tag="$(DOCKER_TAG)" \
		--label build.docker.image.name="$(DOCKER_IMAGE)" \
		--label build.docker.image.created_on="$(shell date -u +"%Y-%m-%dT%H:%M:%SZ")" \
		$(DOCKER_BUILD_ARGS) \
		--force-rm \
		.

build-ecr:
	@$(call check_defined,DOCKER_TAG)

	@$(call logme,"Build base image")
	docker build \
		--file Dockerfile \
		--tag $(ECR_REGISTRY)/$(DOCKER_IMAGE):$(DOCKER_TAG) \
		--label build.commit.hash="$(shell git log -1 --format=%H)" \
		--label build.commit.shorthash="$(shell git log -1 --format=%h)" \
		--label build.docker.image.tag="$(DOCKER_TAG)" \
		--label build.docker.image.name="$(DOCKER_IMAGE)" \
		--label build.docker.image.created_on="$(shell date -u +"%Y-%m-%dT%H:%M:%SZ")" \
		$(DOCKER_BUILD_ARGS) \
		--force-rm \
		.

release: build
	@$(call check_defined,DOCKER_TAG)

	@$(call logme,"Push image and tags")
	docker push $(DOCKER_REGISTRY)/$(DOCKER_IMAGE):$(DOCKER_TAG)

	@echo $(DOCKER_REGISTRY)/$(DOCKER_IMAGE):$(DOCKER_TAG) > /tmp/com.pti.container.image

ecr-release: build-ecr
	@$(call check_defined,DOCKER_TAG)

	@$(call logme,"Push image and tags")
	docker push $(ECR_REGISTRY)/$(DOCKER_IMAGE):${DOCKER_TAG}

test: build
	@$(call check_defined,DOCKER_TAG)

	@$(call logme,"Start verification/unit testing")

	@if [ -x "$(TEST_ENTRYPOINT)" ]; then $(TEST_ENTRYPOINT); else echo "No test entrypoint found, default to success"; fi

.PHONY: all usage clean build release test

# finish common code by trying to include a "local override" makefile
# "sinclude" is used instead of "include" to continue execution if file does
# not exists
sinclude $(HOME)/.pti/pti.local.mk
